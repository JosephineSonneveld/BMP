package nanocourse;

import nano.*;
import java.util.Random;
import java.awt.Color;

public class Exercise3_final {

    public Exercise3_final() {
        // Begin of code for final exercise
        int xSize = 640;
        int ySize = 360;
        Canvas screen = new Canvas(xSize, ySize, 0, 0);
        Pen pen = new Pen(screen);
        Random rnd = new Random();

        //define values initial cells
        int Nr = 60;
        int[] xcells = new int[Nr];
        int[] ycells = new int[Nr];
        int[] dxci = new int[Nr];
        int[] dyci = new int[Nr];
        int[] r = new int[Nr];
        double dist = 0;
        boolean stop = false;

        // boundary intitial cells
        int xupi = 120;
        int xdowni = 0;
        int yupi = ySize;
        int ydown = 0;

        //define values for morphogens.
        int N_morph = 10000000;                 //infinetely long
        int[] xpos_morph = new int[N_morph];                //x_positions morphogen
        int[] ypos_morph = new int[N_morph];                //y_positions morphogen
        int R_morph = 2;                        //Radii morphogen, now just an integer. It's equal for all molecules
        boolean[] morph_exist = new boolean[N_morph];                //whether or not a specific morphogen exists

        int[] dx_morph = new int[N_morph];                //dx morphogen
        int[] dy_morph = new int[N_morph];                //dy morphogen
        int amount_morph = 0;                       //amount of morph that exist at one time point, changes over time!

        //basics for intermediate cells
        int N_intermediate = 10000000;             //infinetely long
        boolean[] intermediate_exist = new boolean[N_intermediate];     //whether or not an intermediate cell exists
        int[] xpos_intermediate = new int[N_intermediate];     //x_positions intermediates
        int[] ypos_intermediate = new int[N_intermediate];     //y_positions intermediates
        int[] R_intermediate = new int[N_intermediate];     //Radii intermediates
        int[] dx_intermediate = new int[N_intermediate];     //dx intermediates
        int[] dy_intermediate = new int[N_intermediate];     //dy intermediates  
        int amount_intermediate = 0;                   //amount of intermediates existing at one time point

        //basics for blue cells
        int N_blue = 10000000;                //infinetely long
        boolean[] blue_exist = new boolean[N_blue];                //wheter or not a blue cell exists
        int[] xpos_blue = new int[N_blue];                //x_positions blue cells
        int[] ypos_blue = new int[N_blue];                //y_positions blue cells
        int[] R_blue = new int[N_blue];                //Radii blue cells
        int[] dx_blue = new int[N_blue];                //dx blue cells
        int[] dy_blue = new int[N_blue];                //dy blue cells
        int amount_blue = 0;                      //amount of blue cells existing at one time point

        //basics for pink cells
        int N_pink = 10000000;                //infinetely long
        boolean[] pink_exist = new boolean[N_pink];                //whether or not a pink cell exists
        int[] xpos_pink = new int[N_pink];                //x_positions pink cells
        int[] ypos_pink = new int[N_pink];                //y_positions pink cells
        int[] R_pink = new int[N_pink];                //Radii pink cells
        int[] dx_pink = new int[N_pink];                //dx pink cells
        int[] dy_pink = new int[N_pink];                //dy pink cells
        int amount_pink = 0;                      //amount of pink cells existing at one time point

        //basics for red cells
        int N_red = 10000000;                 //infinetely long
        boolean[] red_exist = new boolean[N_red];                  //wheter or not a red cell exists
        int[] xpos_red = new int[N_red];                  //x_positions red cells
        int[] ypos_red = new int[N_red];                  //y_positions red cells
        int[] R_red = new int[N_red];                  //Radii red cells
        int[] dx_red = new int[N_red];                  //dx red cells
        int[] dy_red = new int[N_red];                  //dy red cells
        int amount_red = 0;                       //amount of red cells existing at one time point

        
       
        
        
// DRAWING THE STEM CELLS.
        for (int i = 0; i < Nr; i++) {
            boolean Overlap = false;
            do {
                r[i] = rnd.nextInt(10) + 5;                                              //random radius
                xcells[i] = rnd.nextInt(xupi - r[i]) + r[i];                 // random x position
                ycells[i] = rnd.nextInt(ySize - r[i]) + r[i];                   // random y position.
                Overlap = false;
                for (int ii = 0; ii < i; ii++) { // to calculate distance to neighbouring cell

                    int xdistance = Math.abs(xcells[i] - xcells[ii]);
                    double xsqrd = Math.pow(xdistance, 2);
                    int ydistance = Math.abs(ycells[i] - ycells[ii]);
                    double ysqrd = Math.pow(ydistance, 2);
                    double distsqrd = xsqrd + ysqrd;
                    dist = Math.sqrt(distsqrd);                                  // to calculate the distance between two cells. math.sqrt ipv 0.5
                    int R_combined = r[ii] + r[i];                                 //Radii together

                    if (dist < R_combined) {                                         //IF they overlap
                        Overlap = true;

                    } // if dist
                } //end ii loop
            } while (Overlap); //end do loop                         

            pen.drawCircle(xcells[i], ycells[i], r[i], Color.YELLOW, false);
        }
        screen.update();
        screen.pause(5);

// MOVEMENT OF STEM CELLS
        while (stop == false) {
            screen.clear();
            for (int i = 0; i < Nr; i++) {                                             // random x and y velocities    
                dxci[i] = rnd.nextInt(5) - 2;
                dyci[i] = rnd.nextInt(5) - 2;
            }

            for (int i = 0; i < Nr; i++) {
                
                // prevent overlap
                for (int ii = 0; ii < Nr; ii++) {            // you want to check this for all cells so ii<Nr but ii!=i
                    if (i != ii) { // +dx and +dy because you wanna check the spot where they will end up not their current location.
                        if (overlap(xcells[i] + dxci[i], ycells[i] + dyci[i], r[i], xcells[ii], ycells[ii], r[ii]) == true) { //IF they overlap, see method
                          
                             int difference_x = xcells[i] - xcells[ii];
                            int difference_y = ycells[i] - ycells[ii];

                            if (difference_x < 0) {
                                dxci[ii] = Math.abs(dxci[ii]);
                                dxci[i] = -Math.abs(dxci[i]);
                            }
                            if (difference_x > 0) {
                                dxci[i] = Math.abs(dxci[i]);
                                dxci[ii] = -Math.abs(dxci[ii]);
                            }

                            if (difference_y < 0) {
                                dyci[ii] = Math.abs(dyci[ii]);
                                dyci[i] = -Math.abs(dyci[i]);
                            }

                            if (difference_y > 0) {
                                dyci[i] = Math.abs(dyci[i]);
                                dyci[ii] = -Math.abs(dyci[ii]);
                            } 
                        }
                    }
                } // end of ii loop  
                for (int ii=0;ii<amount_intermediate;ii++){
                    if (overlap(xcells[i] + dxci[i], ycells[i] + dyci[i], r[i], xpos_intermediate[ii], ypos_intermediate[ii], R_intermediate[ii]) == true) { //IF they overlap, see method
                          
                             int difference_x = xcells[i] - xpos_intermediate[ii];
                            int difference_y = ycells[i] - ypos_intermediate[ii];

                            if (difference_x < 0) {
                                dx_intermediate[ii] = Math.abs(dx_intermediate[ii]);
                                dxci[i] = -Math.abs(dxci[i]);
                            }
                            if (difference_x > 0) {
                                dxci[i] = Math.abs(dxci[i]);
                                dx_intermediate[ii] = -Math.abs(dx_intermediate[ii]);
                            }

                            if (difference_y < 0) {
                                dy_intermediate[ii] = Math.abs(dy_intermediate[ii]);
                                dyci[i] = -Math.abs(dyci[i]);
                            }

                            if (difference_y > 0) {
                                dyci[i] = Math.abs(dyci[i]);
                                dy_intermediate[ii] = -Math.abs(dy_intermediate[ii]);
                            } 
                }// if overlap
            } // end of ii loop.
                for (int ii=0;ii<amount_blue;ii++){
                    if (overlap(xcells[i] + dxci[i], ycells[i] + dyci[i], r[i], xpos_blue[ii], ypos_blue[ii], R_blue[ii]) == true) { //IF they overlap, see method
                          
                             int difference_x = xcells[i] - xpos_blue[ii];
                            int difference_y = ycells[i] - ypos_blue[ii];

                            if (difference_x < 0) {
                                dx_blue[ii] = Math.abs(dx_blue[ii]);
                                dxci[i] = -Math.abs(dxci[i]);
                            }
                            if (difference_x > 0) {
                                dxci[i] = Math.abs(dxci[i]);
                                dx_blue[ii] = -Math.abs(dx_blue[ii]);
                            }

                            if (difference_y < 0) {
                                dy_blue[ii] = Math.abs(dy_blue[ii]);
                                dyci[i] = -Math.abs(dyci[i]);
                            }

                            if (difference_y > 0) {
                                dyci[i] = Math.abs(dyci[i]);
                                dy_blue[ii] = -Math.abs(dy_blue[ii]);
                            } 
            } // if overlap
                } //ii loop
                for (int ii=0;ii<amount_pink;ii++){
                    if (overlap(xcells[i] + dxci[i], ycells[i] + dyci[i], r[i], xpos_pink[ii], ypos_pink[ii], R_pink[ii]) == true) { //IF they overlap, see method
                          
                             int difference_x = xcells[i] - xpos_pink[ii];
                            int difference_y = ycells[i] - ypos_pink[ii];

                            if (difference_x < 0) {
                                dx_pink[ii] = Math.abs(dx_pink[ii]);
                                dxci[i] = -Math.abs(dxci[i]);
                            }
                            if (difference_x > 0) {
                                dxci[i] = Math.abs(dxci[i]);
                                dx_pink[ii] = -Math.abs(dx_pink[ii]);
                            }

                            if (difference_y < 0) {
                                dy_pink[ii] = Math.abs(dy_pink[ii]);
                                dyci[i] = -Math.abs(dyci[i]);
                            }

                            if (difference_y > 0) {
                                dyci[i] = Math.abs(dyci[i]);
                                dy_pink[ii] = -Math.abs(dy_pink[ii]);
                           }
                    }
                } // ii loop
                for (int ii=0;ii<amount_red;ii++){
                    if (overlap(xcells[i] + dxci[i], ycells[i] + dyci[i], r[i], xpos_red[ii], ypos_red[ii], R_red[ii]) == true) { //IF they overlap, see method
                          
                             int difference_x = xcells[i] - xpos_red[ii];
                            int difference_y = ycells[i] - ypos_red[ii];

                            if (difference_x < 0) {
                                dx_red[ii] = Math.abs(dx_red[ii]);
                                dxci[i] = -Math.abs(dxci[i]);
                            }
                            if (difference_x > 0) {
                                dxci[i] = Math.abs(dxci[i]);
                                dx_red[ii] = -Math.abs(dx_red[ii]);
                            }

                            if (difference_y < 0) {
                                dy_red[ii] = Math.abs(dy_red[ii]);
                                dyci[i] = -Math.abs(dyci[i]);
                            }

                            if (difference_y > 0) {
                                dyci[i] = Math.abs(dyci[i]);
                                dy_red[ii] = -Math.abs(dy_red[ii]);
                            } 
                    }
                }
                    
            } // i loop
   
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 for (int i=0;i<Nr;i++){
                //boundary designated space for initial cells
                int xboundary = out_of_frame_x(xcells[i], r[i], 0, xupi);             //see method at the end of script
                int yboundary = out_of_frame_y(ycells[i], r[i], yupi);             //see method at the end of script

                if (xboundary == 1) {
                    dxci[i] = Math.abs(dxci[i]);
                }                   //if x is at 0, always get a dx>0
                if (xboundary == 2) {
                    dxci[i] = -Math.abs(dxci[i]);
                }                  //if x is at upper bound,  a dx<0

                if (yboundary == 1) {
                    dyci[i] = Math.abs(dyci[i]);
                }                   //if y is at 0, always get a dy>0
                if (yboundary == 2) {
                    dyci[i] = -Math.abs(dyci[i]);
                }                  //if y is at upper bound,  a dy<0

                xcells[i] = xcells[i] + dxci[i];
                ycells[i] = ycells[i] + dyci[i];
            } // end of i loop

// MORPHOGEN existing.
            if (amount_morph > 0) {                                                            // loop is only run if amount of morphogen > 0
                for (int n_morph = 0; n_morph <= amount_morph - 1; n_morph++) {                    // loop runs from 0 to the index of the last morphogen
                    if (morph_exist[n_morph] == true) {                                        // loop is run in an index if morphogen with that index exists
                        int chance_degration = rnd.nextInt(1000);                           // always a chance of degration
                        if (chance_degration == 1 && morph_exist[n_morph] == true) {        // if it degrades
                            morph_exist[amount_morph - 1] = false;                          // the last morphogen ceases to exist
                            xpos_morph[n_morph] = xpos_morph[amount_morph - 1];             // the morphogen entry gains the last morphogen's data
                            xpos_morph[amount_morph - 1] = 0;                               // the last morphogen's data = 0
                            ypos_morph[n_morph] = ypos_morph[amount_morph - 1];             // the morphogen entry gains the last morphogen's data
                            ypos_morph[amount_morph - 1] = 0;                               // the last morphogen's data = 0
                            amount_morph = amount_morph - 1;                                // amount of morphogen decreases by 1
                        }

                        // velocities morphogen.
                        dx_morph[n_morph] = rnd.nextInt(3);
                        if (rnd.nextInt(100) < 60) {
                            dx_morph[n_morph] = Math.abs(dx_morph[n_morph]);
                        }     // slight preference of moving with a positive dx
                        if (rnd.nextInt(100) > 59) {
                            dx_morph[n_morph] = -Math.abs(dx_morph[n_morph]);
                        }    // ^^^
                        dy_morph[n_morph] = rnd.nextInt(7) - 3;

                        // morphogen boundaries
                        int xboundary = out_of_frame_x(xpos_morph[n_morph], R_morph, 0, xSize);     //just like for stem cells, boundaries. Now, upper bound for x is xSize
                        int yboundary = out_of_frame_y(ypos_morph[n_morph], R_morph, ySize);     //like stem cells
                        if (xboundary == 1) {
                            dx_morph[n_morph] = Math.abs(dx_morph[n_morph]);
                        }       //like stem cells
                        if (xboundary == 2) {
                            dx_morph[n_morph] = -Math.abs(dx_morph[n_morph]);
                        }      //like stem cells
                        if (yboundary == 1) {
                            dy_morph[n_morph] = Math.abs(dy_morph[n_morph]);
                        }       //like stem cells
                        if (yboundary == 2) {
                            dy_morph[n_morph] = -Math.abs(dy_morph[n_morph]);
                        }      //like stem cells

                        xpos_morph[n_morph] = xpos_morph[n_morph] + dx_morph[n_morph];
                        ypos_morph[n_morph] = ypos_morph[n_morph] + dy_morph[n_morph];
                    }
                }

                if (amount_morph > 0) {
                    xpos_morph[amount_morph - 1] = xcells[(amount_morph - 1) % Nr];     // if a morphogen exists, give it the x coordinate of a specific stem cell's centre
                    ypos_morph[amount_morph - 1] = ycells[(amount_morph - 1) % Nr];     // if a morphogen exists, give it the y coordinate of a specific stem cell's centre
                }
            }

            // new morphogen.
            int chance_morphogen = rnd.nextInt(10);                                         // probability of morphogen being created
            if (chance_morphogen == 9) {                                                   // if it actually happens, amount of morphogen increases
                amount_morph = amount_morph + 1;
                morph_exist[amount_morph - 1] = true;
            }

// INTERMEDIATE CELLS:
            if (amount_intermediate > 0) {
                for (int n = 0; n < amount_intermediate; n++) {

// DIFFERENTIATION OF INTERMEDIATE CELLS (TO BLUE CELLS).
                    int morph_gradient = amount_of_morphogen(xpos_intermediate[n], ypos_intermediate[n], R_intermediate[n], xpos_morph, ypos_morph, amount_morph - 1);
                    if (morph_gradient > 7 && morph_gradient<11) {//morphogen gradient to differentiate can be adjusted
                        if (amount_blue<Nr){
                        int p_differentiation = rnd.nextInt(10);                             //additionally, probability of actually differentiating when surroundings are OK
                        if (p_differentiation == 0) {                                           //if it actually happens that an intermediate cell differentiates,
                            amount_blue = amount_blue + 1;                                           //extra blue cell
                            xpos_blue[amount_blue - 1] = xpos_intermediate[n];                       //give the new blue cell the coordinates of the (previously) intermediate cell
                            ypos_blue[amount_blue - 1] = ypos_intermediate[n];                       //give the new blue cell the coordinates of the (previously) intermediate cell
                            R_blue[amount_blue - 1] = R_intermediate[n];                          //give the new blue cell the radius      of the (previously) intermediate cell
                            blue_exist[amount_blue - 1] = true;

                            intermediate_exist[amount_intermediate - 1] = false;                     //last intermediate ceases to exist
                            xpos_intermediate[n] = xpos_intermediate[amount_intermediate - 1];       //coordinates are transferred to the gap, where the intermediate has differentiated
                            xpos_intermediate[amount_intermediate - 1] = 0;                          //last entry = 0
                            ypos_intermediate[n] = ypos_intermediate[amount_intermediate - 1];       //coordinates are transferred to the gap, where the intermediate has differentiated
                            ypos_intermediate[amount_intermediate - 1] = 0;                          //last entry = 0
                            dx_intermediate[amount_intermediate - 1] = 0;                            //last entry = 0
                            dy_intermediate[amount_intermediate - 1] = 0;                            //last entry = 0
                            amount_intermediate = amount_intermediate - 1;
                        }
                        }
                    }

// MOVEMENT INTERMEDIATE CELLS
                    dx_intermediate[n] = rnd.nextInt(3) - 1;
                    dy_intermediate[n] = rnd.nextInt(3) - 1;
                    
                    // velocities morphogen.
                        
                       
                        
                    int xboundary = out_of_frame_x(xpos_intermediate[n], R_intermediate[n], xupi, 160);
                    int yboundary = out_of_frame_y(ypos_intermediate[n], R_intermediate[n], ySize);
                    if (xboundary == 1) {
                        dx_intermediate[n] = Math.abs(dx_intermediate[n]);
                    }
                    if (xboundary == 2) {
                        dx_intermediate[n] = -Math.abs(dx_intermediate[n]);
                    }
                    if (yboundary == 1) {
                        dy_intermediate[n] = Math.abs(dy_intermediate[n]);
                    }
                    if (yboundary == 2) {
                        dy_intermediate[n] = -Math.abs(dy_intermediate[n]);
                    }

                    // prevent overlap among initial cells.
                    for (int nn = 0; nn < amount_intermediate; nn++) {
                        if (n != nn) {
                            if (overlap(xpos_intermediate[n] + dx_intermediate[n], ypos_intermediate[n] + dy_intermediate[n], R_intermediate[n], xpos_intermediate[nn], ypos_intermediate[nn], R_intermediate[nn]) == true) {

                                int difference_x = xpos_intermediate[n] - xpos_intermediate[nn];
                                int difference_y = ypos_intermediate[n] - ypos_intermediate[nn];

                                if (difference_x < 0) {
                                    dx_intermediate[nn] = Math.abs(dx_intermediate[nn]);
                                    dx_intermediate[n] = -Math.abs(dx_intermediate[n]);
                                }
                                if (difference_x > 0) {
                                    dx_intermediate[n] = Math.abs(dx_intermediate[n]);
                                    dx_intermediate[nn] = -Math.abs(dx_intermediate[nn]);
                                }

                                if (difference_y < 0) {
                                    dy_intermediate[nn] = Math.abs(dy_intermediate[nn]);
                                    dy_intermediate[n] = -Math.abs(dy_intermediate[n]);
                                }
                                if (difference_y > 0) {
                                    dy_intermediate[n] = Math.abs(dy_intermediate[n]);
                                    dy_intermediate[nn] = -Math.abs(dy_intermediate[nn]);

                                   
                                }
                            } // if overlap
                        } // if n!=nn
                    } // loop nn
                    // overlap intermediate vs stem.
                    for (int nn = 0; nn < Nr; nn++) {
                        
                            if (overlap(xpos_intermediate[n] + dx_intermediate[n], ypos_intermediate[n] + dy_intermediate[n], R_intermediate[n], xcells[nn], ycells[nn], r[nn]) == true) {

                                int difference_x = xpos_intermediate[n] - xcells[nn];
                                int difference_y = ypos_intermediate[n] - ycells[nn];

                                if (difference_x < 0) {
                                    dxci[nn] = Math.abs(dxci[nn]);
                                    dx_intermediate[n] = -Math.abs(dx_intermediate[n]);
                                }
                                if (difference_x > 0) {
                                    dx_intermediate[n] = Math.abs(dx_intermediate[n]);
                                    dxci[nn] = -Math.abs(dxci[nn]);
                                }

                                if (difference_y < 0) {
                                    dyci[nn] = Math.abs(dyci[nn]);
                                    dy_intermediate[n] = -Math.abs(dy_intermediate[n]);
                                }
                                if (difference_y > 0) {
                                    dy_intermediate[n] = Math.abs(dy_intermediate[n]);
                                    dyci[nn] = -Math.abs(dyci[nn]);

                                   
                                }
                            } // if overlap
                        
                    } // loop nn
                                // overlap intermediate vs blue
                                for (int nn = 0; nn < amount_blue; nn++) {
                        
                            if (overlap(xpos_intermediate[n] + dx_intermediate[n], ypos_intermediate[n] + dy_intermediate[n], R_intermediate[n], xpos_blue[nn], ypos_blue[nn], R_blue[nn]) == true) {

                                int difference_x = xpos_intermediate[n] - xpos_blue[nn];
                                int difference_y = ypos_intermediate[n] - ypos_blue[nn];

                                if (difference_x < 0) {
                                    dx_blue[nn] = Math.abs(dx_blue[nn]);
                                    dx_intermediate[n] = -Math.abs(dx_intermediate[n]);
                                }
                                if (difference_x > 0) {
                                    dx_intermediate[n] = Math.abs(dx_intermediate[n]);
                                    dx_blue[nn] = -Math.abs(dx_blue[nn]);
                                }

                                if (difference_y < 0) {
                                    dy_blue[nn] = Math.abs(dy_blue[nn]);
                                    dy_intermediate[n] = -Math.abs(dy_intermediate[n]);
                                }
                                if (difference_y > 0) {
                                    dy_intermediate[n] = Math.abs(dy_intermediate[n]);
                                    dy_blue[nn] = -Math.abs(dy_blue[nn]);

                                   
                                }
                            } // if overlap
                        
                    } // loop nn
                                // intermediate vs pink
                                for (int nn = 0; nn < amount_pink; nn++) {
                        
                            if (overlap(xpos_intermediate[n] + dx_intermediate[n], ypos_intermediate[n] + dy_intermediate[n], R_intermediate[n], xpos_pink[nn], ypos_pink[nn], R_pink[nn]) == true) {

                                int difference_x = xpos_intermediate[n] - xpos_pink[nn];
                                int difference_y = ypos_intermediate[n] - ypos_pink[nn];

                                if (difference_x < 0) {
                                    dx_pink[nn] = Math.abs(dx_pink[nn]);
                                    dx_intermediate[n] = -Math.abs(dx_intermediate[n]);
                                }
                                if (difference_x > 0) {
                                    dx_intermediate[n] = Math.abs(dx_intermediate[n]);
                                    dx_pink[nn] = -Math.abs(dx_pink[nn]);
                                }

                                if (difference_y < 0) {
                                    dy_pink[nn] = Math.abs(dy_pink[nn]);
                                    dy_intermediate[n] = -Math.abs(dy_intermediate[n]);
                                }
                                if (difference_y > 0) {
                                    dy_intermediate[n] = Math.abs(dy_intermediate[n]);
                                    dy_pink[nn] = -Math.abs(dy_pink[nn]);

                                   
                                }
                            } // if overlap
                        
                    } // loop nn
                                // intermediate vs red
                                for (int nn = 0; nn < amount_red; nn++) {
                        
                            if (overlap(xpos_intermediate[n] + dx_intermediate[n], ypos_intermediate[n] + dy_intermediate[n], R_intermediate[n], xpos_red[nn], ypos_red[nn], R_red[nn]) == true) {

                                int difference_x = xpos_intermediate[n] - xpos_red[nn];
                                int difference_y = ypos_intermediate[n] - ypos_red[nn];

                                if (difference_x < 0) {
                                    dx_red[nn] = Math.abs(dx_red[nn]);
                                    dx_intermediate[n] = -Math.abs(dx_intermediate[n]);
                                }
                                if (difference_x > 0) {
                                    dx_intermediate[n] = Math.abs(dx_intermediate[n]);
                                    dx_red[nn] = -Math.abs(dx_red[nn]);
                                }

                                if (difference_y < 0) {
                                    dy_red[nn] = Math.abs(dy_red[nn]);
                                    dy_intermediate[n] = -Math.abs(dy_intermediate[n]);
                                }
                                if (difference_y > 0) {
                                    dy_intermediate[n] = Math.abs(dy_intermediate[n]);
                                    dy_red[nn] = -Math.abs(dy_red[nn]);

                                   
                                }
                            } // if overlap
                        
                    } // loop nn
                    

                    xpos_intermediate[n] = xpos_intermediate[n] + dx_intermediate[n];
                    ypos_intermediate[n] = ypos_intermediate[n] + dy_intermediate[n];
                } //nloop
            }//end of intermediate cells
           
// BLUE CELLS:
            for (int n = 0; n < amount_blue; n++) {
// BLUE CELLS DIFFERENTIATING 
                int morph_gradient = amount_of_morphogen(xpos_blue[n], ypos_blue[n], R_blue[n], xpos_morph, ypos_morph, amount_morph - 1);
                
                if (amount_pink<amount_blue){    
                if (morph_gradient > 10 && morph_gradient < 17 ) {
                    int p_differentiation = rnd.nextInt(9);
                    if (p_differentiation == 0) {
                        amount_pink = amount_pink + 1;
                        xpos_pink[amount_pink - 1] = xpos_blue[n];
                        ypos_pink[amount_pink - 1] = ypos_blue[n];
                        R_pink[amount_pink - 1] = R_blue[n];
                        pink_exist[amount_pink - 1] = true;

                        blue_exist[n] = false;
                        xpos_blue[n] = xpos_blue[amount_blue - 1];
                        xpos_blue[amount_blue - 1] = 0;
                        ypos_blue[n] = ypos_blue[amount_blue - 1];
                        ypos_blue[amount_blue - 1] = 0;
                        dx_blue[amount_blue - 1] = 0;
                        dy_blue[amount_blue - 1] = 0;
                        amount_blue = amount_blue - 1;
                    }
                }}

// BLUE CELLS MOVEMENT
                dx_blue[n] = rnd.nextInt(3) - 1;
                dy_blue[n] = rnd.nextInt(3) - 1;
                
              
                        
                        int xboundary = out_of_frame_x(xpos_blue[n], R_blue[n], 180, 400);
                int yboundary = out_of_frame_y(ypos_blue[n], R_blue[n], ySize);
                if (xboundary == 1) {
                    dx_blue[n] = Math.abs(dx_blue[n]);
                }
                if (xboundary == 2) {
                    dx_blue[n] = -Math.abs(dx_blue[n]);
                }
                if (yboundary == 1) {
                    dy_blue[n] = Math.abs(dy_blue[n]);
                }
                if (yboundary == 2) {
                    dy_blue[n] = -Math.abs(dy_blue[n]);
                }
                
                // prevent overlap among blue cells
                for (int nn = 0; nn < amount_blue; nn++) {
                    if (n != nn) {
                        if (overlap(xpos_blue[n] + dx_blue[n], ypos_blue[n] + dy_blue[n], R_blue[n], xpos_blue[nn], ypos_blue[nn], R_blue[nn]) == true) {
                            int difference_x = xpos_blue[n] - xpos_blue[nn];
                            int difference_y = ypos_blue[n] - ypos_blue[nn];

                            if (difference_x < 0) {
                                dx_blue[nn] = Math.abs(dx_blue[nn]);
                                dx_blue[n] = -Math.abs(dx_blue[n]);
                            }
                            if (difference_x > 0) {
                                dx_blue[n] = Math.abs(dx_blue[n]);
                                dx_blue[nn] = -Math.abs(dx_blue[nn]);
                            }

                            if (difference_y < 0) {
                                dy_blue[nn] = Math.abs(dy_blue[nn]);
                                dy_blue[n] = -Math.abs(dy_blue[n]);
                            }
                            if (difference_y > 0) {
                                dy_blue[n] = Math.abs(dy_blue[n]);
                                dy_blue[nn] = -Math.abs(dy_blue[nn]);
                                
                                if (xpos_blue[nn]<=120){
                                    dx_blue[nn]=-dx_blue[nn];
                                    dx_blue[n]=-dx_blue[n];
                                }
                               
                            }
                            
                        }
                    }
                }
                // blue vs stem
                for (int nn = 0; nn < Nr; nn++) {
                        
                            if (overlap(xpos_blue[n] + dx_blue[n], ypos_blue[n] + dy_blue[n], R_blue[n], xcells[nn], ycells[nn], r[nn]) == true) {

                                int difference_x = xpos_blue[n] - xcells[nn];
                                int difference_y = ypos_blue[n] - ycells[nn];

                                if (difference_x < 0) {
                                    dxci[nn] = Math.abs(dxci[nn]);
                                    dx_blue[n] = -Math.abs(dx_blue[n]);
                                }
                                if (difference_x > 0) {
                                    dx_blue[n] = Math.abs(dx_blue[n]);
                                    dxci[nn] = -Math.abs(dxci[nn]);
                                }

                                if (difference_y < 0) {
                                    dyci[nn] = Math.abs(dyci[nn]);
                                    dy_blue[n] = -Math.abs(dy_blue[n]);
                                }
                                if (difference_y > 0) {
                                    dy_blue[n] = Math.abs(dy_blue[n]);
                                    dyci[nn] = -Math.abs(dyci[nn]);

                                   
                                }
                            } // if overlap
                        
                    } // loop nn
                // blue vs intermediate
                 for (int nn = 0; nn < amount_intermediate; nn++) {
                        
                            if (overlap(xpos_blue[n] + dx_blue[n], ypos_blue[n] + dy_blue[n], R_blue[n], xpos_intermediate[nn], ypos_intermediate[nn], R_intermediate[nn]) == true) {

                                int difference_x = xpos_blue[n] - xpos_intermediate[nn];
                                int difference_y = ypos_blue[n] - ypos_intermediate[nn];

                                if (difference_x < 0) {
                                    dx_intermediate[nn] = Math.abs(dx_intermediate[nn]);
                                    dx_blue[n] = -Math.abs(dx_blue[n]);
                                }
                                if (difference_x > 0) {
                                    dx_blue[n] = Math.abs(dx_blue[n]);
                                    dx_intermediate[nn] = -Math.abs(dx_intermediate[nn]);
                                }

                                if (difference_y < 0) {
                                    dy_intermediate[nn] = Math.abs(dy_intermediate[nn]);
                                    dy_blue[n] = -Math.abs(dy_blue[n]);
                                }
                                if (difference_y > 0) {
                                    dy_blue[n] = Math.abs(dy_blue[n]);
                                    dy_intermediate[nn] = -Math.abs(dy_intermediate[nn]);

                                   
                                }
                            } // if overlap
                        
                    } // loop nn
                 // blue vs pink
                  for (int nn = 0; nn < amount_pink; nn++) {
                        
                            if (overlap(xpos_blue[n] + dx_blue[n], ypos_blue[n] + dy_blue[n], R_blue[n], xpos_pink[nn], ypos_pink[nn], R_pink[nn]) == true) {

                                int difference_x = xpos_blue[n] - xpos_pink[nn];
                                int difference_y = ypos_blue[n] - ypos_pink[nn];

                                if (difference_x < 0) {
                                    dx_pink[nn] = Math.abs(dx_pink[nn]);
                                    dx_blue[n] = -Math.abs(dx_blue[n]);
                                }
                                if (difference_x > 0) {
                                    dx_blue[n] = Math.abs(dx_blue[n]);
                                    dx_pink[nn] = -Math.abs(dx_pink[nn]);
                                }

                                if (difference_y < 0) {
                                    dy_pink[nn] = Math.abs(dy_pink[nn]);
                                    dy_blue[n] = -Math.abs(dy_blue[n]);
                                }
                                if (difference_y > 0) {
                                    dy_blue[n] = Math.abs(dy_blue[n]);
                                    dy_pink[nn] = -Math.abs(dy_pink[nn]);

                                   
                                }
                            } // if overlap
                        
                    } // loop nn
                  // blue vs red
                   for (int nn = 0; nn < amount_red; nn++) {
                        
                            if (overlap(xpos_blue[n] + dx_blue[n], ypos_blue[n] + dy_blue[n], R_blue[n], xpos_red[nn], ypos_red[nn], R_red[nn]) == true) {

                                int difference_x = xpos_blue[n] - xpos_red[nn];
                                int difference_y = ypos_blue[n] - ypos_red[nn];

                                if (difference_x < 0) {
                                    dx_red[nn] = Math.abs(dx_red[nn]);
                                    dx_blue[n] = -Math.abs(dx_blue[n]);
                                }
                                if (difference_x > 0) {
                                    dx_blue[n] = Math.abs(dx_blue[n]);
                                    dx_red[nn] = -Math.abs(dx_red[nn]);
                                }

                                if (difference_y < 0) {
                                    dy_red[nn] = Math.abs(dy_red[nn]);
                                    dy_blue[n] = -Math.abs(dy_blue[n]);
                                }
                                if (difference_y > 0) {
                                    dy_blue[n] = Math.abs(dy_blue[n]);
                                    dy_red[nn] = -Math.abs(dy_red[nn]);

                                   
                                }
                            } // if overlap
                        
                    } // loop nn
                
            }
            for (int n = 0; n < amount_blue; n++) {
                xpos_blue[n] = xpos_blue[n] + dx_blue[n];
                ypos_blue[n] = ypos_blue[n] + dy_blue[n];
            }       //end of blue cells

// PINK CELLS:
            for (int n = 0; n < amount_pink; n++) {
//PINK CELLS DIFFERENTIATING
                int morph_gradient = amount_of_morphogen(xpos_pink[n], ypos_pink[n], R_pink[n], xpos_morph, ypos_morph, amount_morph - 1);
                
               if (amount_red<amount_pink){
                if (morph_gradient >=15 ){
                
                    int p_differentiation =rnd.nextInt(9);
                    if (p_differentiation == 0) {
                        amount_red = amount_red + 1;
                        xpos_red[amount_red - 1] = xpos_pink[n];
                        ypos_red[amount_red - 1] = ypos_pink[n];
                        R_red[amount_red - 1] = R_pink[n];
                        red_exist[amount_red - 1] = true;

                        pink_exist[n] = false;
                        xpos_pink[n] = xpos_pink[amount_pink - 1];
                        xpos_pink[amount_pink - 1] = 0;
                        ypos_pink[n] = ypos_pink[amount_pink - 1];
                        ypos_pink[amount_pink - 1] = 0;
                        dx_pink[amount_pink - 1] = 0;
                        dy_pink[amount_pink - 1] = 0;
                        amount_pink = amount_pink - 1;
                    
                }}}

// PINK CELLS MOVEMENT
                dx_pink[n] = rnd.nextInt(3) - 1;
                dy_pink[n] = rnd.nextInt(3) - 1;
                
               
                // prevent overlap among pink cells
                for (int nn = 0; nn < amount_pink; nn++) {
                    if (n != nn) {
                        if (overlap(xpos_pink[n] + dx_pink[n], ypos_pink[n] + dy_pink[n], R_pink[n], xpos_pink[nn], ypos_pink[nn], R_pink[nn]) == true) {
                            int difference_x = xpos_pink[n] - xpos_pink[nn];
                            int difference_y = ypos_pink[n] - ypos_pink[nn];

                            if (difference_x < 0) {
                                dx_pink[nn] = Math.abs(dx_pink[nn]);
                                dx_pink[n] = -Math.abs(dx_pink[n]);
                            }
                            if (difference_x > 0) {
                                dx_pink[n] = Math.abs(dx_pink[n]);
                                dx_pink[nn] = -Math.abs(dx_pink[nn]);
                            }

                            if (difference_y < 0) {
                                dy_pink[nn] = Math.abs(dy_pink[nn]);
                                dy_pink[n] = -Math.abs(dy_pink[n]);
                            }
                            if (difference_y > 0) {
                                dy_pink[n] = Math.abs(dy_pink[n]);
                                dy_pink[nn] = -Math.abs(dy_pink[nn]);
                            }
                        } // if overlap
                    }// if n!=nn
                } // nn loop
                
                // pink vs stem
                 for (int nn = 0; nn < Nr; nn++) {
                        
                            if (overlap(xpos_pink[n] + dx_pink[n], ypos_pink[n] + dy_pink[n], R_pink[n], xcells[nn], ycells[nn], r[nn]) == true) {

                                int difference_x = xpos_pink[n] - xcells[nn];
                                int difference_y = ypos_pink[n] - ycells[nn];

                                if (difference_x < 0) {
                                    dxci[nn] = Math.abs(dxci[nn]);
                                    dx_pink[n] = -Math.abs(dx_pink[n]);
                                }
                                if (difference_x > 0) {
                                    dx_pink[n] = Math.abs(dx_pink[n]);
                                    dxci[nn] = -Math.abs(dxci[nn]);
                                }

                                if (difference_y < 0) {
                                    dyci[nn] = Math.abs(dyci[nn]);
                                    dy_pink[n] = -Math.abs(dy_pink[n]);
                                }
                                if (difference_y > 0) {
                                    dy_pink[n] = Math.abs(dy_pink[n]);
                                    dyci[nn] = -Math.abs(dyci[nn]);

                                   
                                }
                            } // if overlap
                        
                    } // loop nn
                 //pink vs intermediate
                 for (int nn = 0; nn < amount_intermediate; nn++) {
                        
                            if (overlap(xpos_pink[n] + dx_pink[n], ypos_pink[n] + dy_pink[n], R_pink[n], xpos_intermediate[nn], ypos_intermediate[nn], R_intermediate[nn]) == true) {

                                int difference_x = xpos_pink[n] - xpos_intermediate[nn];
                                int difference_y = ypos_pink[n] - ypos_intermediate[nn];

                                if (difference_x < 0) {
                                    dx_intermediate[nn] = Math.abs(dx_intermediate[nn]);
                                    dx_pink[n] = -Math.abs(dx_pink[n]);
                                }
                                if (difference_x > 0) {
                                    dx_pink[n] = Math.abs(dx_pink[n]);
                                    dx_intermediate[nn] = -Math.abs(dx_intermediate[nn]);
                                }

                                if (difference_y < 0) {
                                    dy_intermediate[nn] = Math.abs(dy_intermediate[nn]);
                                    dy_pink[n] = -Math.abs(dy_pink[n]);
                                }
                                if (difference_y > 0) {
                                    dy_pink[n] = Math.abs(dy_pink[n]);
                                    dy_intermediate[nn] = -Math.abs(dy_intermediate[nn]);

                                   
                                }
                            } // if overlap
                        
                    } // loop nn
                 // pink vs blue
                 for (int nn = 0; nn < amount_blue; nn++) {
                        
                            if (overlap(xpos_pink[n] + dx_pink[n], ypos_pink[n] + dy_pink[n], R_pink[n], xpos_blue[nn], ypos_blue[nn], R_blue[nn]) == true) {

                                int difference_x = xpos_pink[n] - xpos_blue[nn];
                                int difference_y = ypos_pink[n] - ypos_blue[nn];

                                if (difference_x < 0) {
                                    dx_blue[nn] = Math.abs(dx_blue[nn]);
                                    dx_pink[n] = -Math.abs(dx_pink[n]);
                                }
                                if (difference_x > 0) {
                                    dx_pink[n] = Math.abs(dx_pink[n]);
                                    dx_blue[nn] = -Math.abs(dx_blue[nn]);
                                }

                                if (difference_y < 0) {
                                    dy_blue[nn] = Math.abs(dy_blue[nn]);
                                    dy_pink[n] = -Math.abs(dy_pink[n]);
                                }
                                if (difference_y > 0) {
                                    dy_pink[n] = Math.abs(dy_pink[n]);
                                    dy_blue[nn] = -Math.abs(dy_blue[nn]);

                                   
                                }
                            } // if overlap
                        
                    } // loop nn
                 // pink vs red.
                 for (int nn = 0; nn < amount_red; nn++) {
                        
                            if (overlap(xpos_pink[n] + dx_pink[n], ypos_pink[n] + dy_pink[n], R_pink[n], xpos_red[nn], ypos_red[nn], R_red[nn]) == true) {

                                int difference_x = xpos_pink[n] - xpos_red[nn];
                                int difference_y = ypos_pink[n] - ypos_red[nn];

                                if (difference_x < 0) {
                                    dx_red[nn] = Math.abs(dx_red[nn]);
                                    dx_pink[n] = -Math.abs(dx_pink[n]);
                                }
                                if (difference_x > 0) {
                                    dx_pink[n] = Math.abs(dx_pink[n]);
                                    dx_red[nn] = -Math.abs(dx_red[nn]);
                                }

                                if (difference_y < 0) {
                                    dy_red[nn] = Math.abs(dy_red[nn]);
                                    dy_pink[n] = -Math.abs(dy_pink[n]);
                                }
                                if (difference_y > 0) {
                                    dy_pink[n] = Math.abs(dy_pink[n]);
                                    dy_red[nn] = -Math.abs(dy_red[nn]);

                                   
                                }
                            } // if overlap
                        
                    } // loop nn
                 
                // boundary pixels
                int xboundary = out_of_frame_x(xpos_pink[n], R_pink[n], 460, 580);
                int yboundary = out_of_frame_y(ypos_pink[n], R_pink[n], ySize);
                if (xboundary == 1) {
                    dx_pink[n] = Math.abs(dx_pink[n]);
                }
                if (xboundary == 2) {
                    dx_pink[n] = -Math.abs(dx_pink[n]);
                }
                if (yboundary == 1) {
                    dy_pink[n] = Math.abs(dy_pink[n]);
                }
                if (yboundary == 2) {
                    dy_pink[n] = -Math.abs(dy_pink[n]);
                }

                xpos_pink[n] = xpos_pink[n] + dx_pink[n];
                ypos_pink[n] = ypos_pink[n] + dy_pink[n];
            }                                  //end of pink cells

// RED CELLS:          
 
// RED CELLS MOVEMENT
            for (int n = 0; n < amount_red; n++) {
                dx_red[n] = rnd.nextInt(3) - 1;
                dy_red[n] = rnd.nextInt(3) - 1;
              
                
                int xboundary = out_of_frame_x(xpos_red[n], R_red[n], xupi, xSize);
                int yboundary = out_of_frame_y(ypos_red[n], R_red[n], ySize);

                if (xboundary == 1) {
                    dx_red[n] = Math.abs(dx_red[n]);
                }
                if (xboundary == 2) {
                    dx_red[n] = -Math.abs(dx_red[n]);
                }
                if (yboundary == 1) {
                    dy_red[n] = Math.abs(dy_red[n]);
                }
                if (yboundary == 2) {
                    dy_red[n] = -Math.abs(dy_red[n]);
                }
                for (int nn = 0; nn < amount_red; nn++) {
                    if (overlap(xpos_red[n] + dx_red[n], ypos_red[n] + dy_red[n], R_red[n], xpos_red[nn], ypos_red[nn], R_red[nn])) {
                        int x_div = xpos_red[n] - xpos_red[nn];
                        int y_div = ypos_red[n] - ypos_red[nn];

                        if (x_div < 0) {
                            dx_red[nn] = Math.abs(dx_red[nn]);
                            dx_red[n] = -Math.abs(dx_red[n]);
                        }
                        if (x_div > 0) {
                            dx_red[n] = Math.abs(dx_red[n]);
                            dx_red[nn] = -Math.abs(dx_red[nn]);
                        }

                        if (y_div < 0) {
                            dy_red[nn] = Math.abs(dy_red[nn]);
                            dy_red[n] = -Math.abs(dy_red[n]);
                        }
                        if (y_div > 0) {
                            dy_red[n] = Math.abs(dy_red[n]);
                            dy_red[nn] = -Math.abs(dy_red[nn]);
                        }

                    }
                } // nnloop
                // red vs stem
                for (int nn = 0; nn < Nr; nn++) {
                        
                            if (overlap(xpos_red[n] + dx_red[n], ypos_red[n] + dy_red[n], R_red[n], xcells[nn], ycells[nn], r[nn]) == true) {

                                int difference_x = xpos_red[n] - xcells[nn];
                                int difference_y = ypos_red[n] - ycells[nn];

                                if (difference_x < 0) {
                                    dxci[nn] = Math.abs(dxci[nn]);
                                    dx_red[n] = -Math.abs(dx_red[n]);
                                }
                                if (difference_x > 0) {
                                    dx_red[n] = Math.abs(dx_red[n]);
                                    dxci[nn] = -Math.abs(dxci[nn]);
                                }

                                if (difference_y < 0) {
                                    dyci[nn] = Math.abs(dyci[nn]);
                                    dy_red[n] = -Math.abs(dy_red[n]);
                                }
                                if (difference_y > 0) {
                                    dy_red[n] = Math.abs(dy_red[n]);
                                    dyci[nn] = -Math.abs(dyci[nn]);

                                   
                                }
                            } // if overlap
                        
                    } // loop nn
                // red vs intermediate
                for (int nn = 0; nn < amount_intermediate; nn++) {
                        
                            if (overlap(xpos_red[n] + dx_red[n], ypos_red[n] + dy_red[n], R_red[n], xpos_intermediate[nn], ypos_intermediate[nn], R_intermediate[nn]) == true) {

                                int difference_x = xpos_red[n] - xpos_intermediate[nn];
                                int difference_y = ypos_red[n] - ypos_intermediate[nn];

                                if (difference_x < 0) {
                                    dx_intermediate[nn] = Math.abs(dx_intermediate[nn]);
                                    dx_red[n] = -Math.abs(dx_red[n]);
                                }
                                if (difference_x > 0) {
                                    dx_red[n] = Math.abs(dx_red[n]);
                                    dx_intermediate[nn] = -Math.abs(dx_intermediate[nn]);
                                }

                                if (difference_y < 0) {
                                    dy_intermediate[nn] = Math.abs(dy_intermediate[nn]);
                                    dy_red[n] = -Math.abs(dy_red[n]);
                                }
                                if (difference_y > 0) {
                                    dy_red[n] = Math.abs(dy_red[n]);
                                    dy_intermediate[nn] = -Math.abs(dy_intermediate[nn]);

                                   
                                }
                            } // if overlap
                        
                    } // loop nn
                // red vs blue
                for (int nn = 0; nn < amount_blue; nn++) {
                        
                            if (overlap(xpos_red[n] + dx_red[n], ypos_red[n] + dy_red[n], R_red[n], xpos_blue[nn], ypos_blue[nn], R_blue[nn]) == true) {

                                int difference_x = xpos_red[n] - xpos_blue[nn];
                                int difference_y = ypos_red[n] - ypos_blue[nn];

                                if (difference_x < 0) {
                                    dx_blue[nn] = Math.abs(dx_blue[nn]);
                                    dx_red[n] = -Math.abs(dx_red[n]);
                                }
                                if (difference_x > 0) {
                                    dx_red[n] = Math.abs(dx_red[n]);
                                    dx_blue[nn] = -Math.abs(dx_blue[nn]);
                                }

                                if (difference_y < 0) {
                                    dy_blue[nn] = Math.abs(dy_blue[nn]);
                                    dy_red[n] = -Math.abs(dy_red[n]);
                                }
                                if (difference_y > 0) {
                                    dy_red[n] = Math.abs(dy_red[n]);
                                    dy_blue[nn] = -Math.abs(dy_blue[nn]);

                                   
                                }
                            } // if overlap
                        
                    } // loop nn
                // red vs pink
                for (int nn = 0; nn < amount_pink; nn++) {
                        
                            if (overlap(xpos_red[n] + dx_red[n], ypos_red[n] + dy_red[n], R_red[n], xpos_pink[nn], ypos_pink[nn], R_pink[nn]) == true) {

                                int difference_x = xpos_red[n] - xpos_pink[nn];
                                int difference_y = ypos_red[n] - ypos_pink[nn];

                                if (difference_x < 0) {
                                    dx_pink[nn] = Math.abs(dx_pink[nn]);
                                    dx_red[n] = -Math.abs(dx_red[n]);
                                }
                                if (difference_x > 0) {
                                    dx_red[n] = Math.abs(dx_red[n]);
                                    dx_pink[nn] = -Math.abs(dx_pink[nn]);
                                }

                                if (difference_y < 0) {
                                    dy_pink[nn] = Math.abs(dy_pink[nn]);
                                    dy_red[n] = -Math.abs(dy_red[n]);
                                }
                                if (difference_y > 0) {
                                    dy_red[n] = Math.abs(dy_red[n]);
                                    dy_pink[nn] = -Math.abs(dy_pink[nn]);

                                   
                                }
                            } // if overlap
                        
                    } // loop nn

                xpos_red[n] = xpos_red[n] + dx_red[n];
                ypos_red[n] = ypos_red[n] + dy_red[n];
            }                                     //end of red cells

// CELL DIVISION (STEM CELLS)
            for (int i = 0; i < Nr; i++) {
                if (amount_intermediate<Nr){
                int chance_division = rnd.nextInt(1000 );
                if (chance_division == 0) {
                    for (int jj = 0; jj < Nr; jj++) {
                        for (int k = 0; k < 25; k++) {                                           //if there's room, checked by adding or subtracting R from the x and y coordinates
                            int y_rnd = rnd.nextInt(3) - 1;
                            int x_potential = xcells[i] + r[i];
                            int y_potential = ycells[i] + r[i] * y_rnd;
                            int R_potential = r[i];
                            if (i < jj || jj < i) {
                                if (overlap(x_potential, y_potential, R_potential, xcells[jj], ycells[jj], r[jj]) == false
                                        && overlap(x_potential, y_potential, R_potential, xpos_intermediate[jj], ypos_intermediate[jj], R_intermediate[jj]) == false
                                        && overlap(x_potential, y_potential, R_potential, xpos_blue[jj], ypos_blue[jj], R_blue[jj]) == false
                                        && overlap(x_potential, y_potential, R_potential, xpos_pink[jj], ypos_pink[jj], R_pink[jj]) == false
                                        && overlap(x_potential, y_potential, R_potential, xpos_red[jj], ypos_red[jj], R_red[jj]) == false 
                                        && x_potential>xupi-r[i]) {
                                    

                                    amount_intermediate = amount_intermediate + 1;
                                    intermediate_exist[amount_intermediate - 1] = true;
                                    xpos_intermediate[amount_intermediate - 1] = x_potential;
                                    ypos_intermediate[amount_intermediate - 1] = y_potential;
                                    R_intermediate[amount_intermediate - 1] = R_potential;
                                    k = 100;
                                    jj = Nr;
                                }
                            
                                
                            }
                        }
                    }
                }
            }}
            
          

            // drawing.
            for (int i = 0; i < Nr; i++) {

                pen.drawCircle(xcells[i], ycells[i], r[i], Color.WHITE, false);
            }

            if (amount_morph > 0) {
                for (int i = 0; i < amount_morph; i++) {
                    if (morph_exist[i] == true) {
                        pen.drawCircle(xpos_morph[i], ypos_morph[i], R_morph, Color.GREEN, true);
                    }
                }
            }

            if (amount_intermediate > 0) {
                for (int i = 0; i < amount_intermediate; i++) {
                    pen.drawCircle(xpos_intermediate[i], ypos_intermediate[i], R_intermediate[i], Color.YELLOW, true);
                }
            }

            if (amount_blue > 0) {
                for (int i = 0; i < amount_blue; i++) {
                    pen.drawCircle(xpos_blue[i], ypos_blue[i], R_blue[i], Color.BLUE, true);
                }
            }

            if (amount_pink > 0) {
                for (int i = 0; i < amount_pink; i++) {
                    pen.drawCircle(xpos_pink[i], ypos_pink[i], R_pink[i], Color.PINK, true);
                }
            }

            if (amount_red > 0) {
                for (int i = 0; i < amount_red; i++) {
                    pen.drawCircle(xpos_red[i], ypos_red[i], R_red[i], Color.RED, true);
                }
            }

            screen.update();
            screen.pause(5);
        } // while loop  
        // End of code
    } // final

    // write new method below this line
    // methods hier uitgewerkt
    public boolean overlap(int x1, int y1, int R1, int x2, int y2, int R2) {
        boolean Overlap = false;
        int xdistance = Math.abs(x1 - x2);
        double xsqrd = Math.pow(xdistance, 2);
        int ydistance = Math.abs(y1 - y2);
        double ysqrd = Math.pow(ydistance, 2);
        double distsqrd = xsqrd + ysqrd;
        double distance = Math.sqrt(distsqrd);
        int R_combined = R1 + R2;
        if (distance <= R_combined) {
            Overlap = true;
        }
        return Overlap;
    }

    public int out_of_frame_x(int x, int R, int xdown, int xup) {
        int xbndry = 0;
        if (x - R <= 0) {
            xbndry = 1;
        }
        if (x + R >= xup) {
            xbndry = 2;
        }
        return (xbndry);
    }

    public int out_of_frame_y(int y, int R, int yup) {
        int ybndry = 0;
        if (y - R <= 0) {
            ybndry = 1;
        }
        if (y + R >= yup) {
            ybndry = 2;
        }
        return (ybndry);
    }

    public int amount_of_morphogen(int x, int y, int R, int[] x_morph, int[] y_morph, int N_m) {
        int amount = 0;
        for (int i = 0; i < N_m; i++) {
            if (overlap(x, y, R * 3, x_morph[i], y_morph[i], 0) == true) {
                amount = amount + 1;
            }
        }
        return (amount);
    }

    public static void main(String[] args) {
        Exercise3_final e = new Exercise3_final();
    }
}
